#include "IO_VTK_SDM.h"

#include "shared/utils.h"  // for get_current_date
#include "shared/enums.h"  // for ComponentIndex3D (IX,IY,IZ)

namespace ppkMHD { namespace io {

// =======================================================
// =======================================================
static bool isBigEndian()
{
  const int i = 1;
  return ( (*(char*)&i) == 0 );
}

// =======================================================
// =======================================================
void write_vtu_header(std::ostream& outFile,	
		      ConfigMap& configMap)
{

  bool outputVtkAscii = configMap.getBool("output", "outputVtkAscii", false);
  bool outputDataAndTime = configMap.getBool("output", "outputDataAndTime", false);
  
  // if writing raw binary data (file does not respect XML standard)
  if (outputVtkAscii)
    outFile << "<?xml version=\"1.0\"?>\n";

  // print data and time
  outFile << "<!-- \n";
  outFile << "# vtk DataFile Version 3.0"
	  << '\n'
	  << "#This file was generated by ppkMHD";
  if (outputDataAndTime) {
    outFile << " on " << get_current_date();
  } else {
    outFile << ".";
  }
  outFile << "\n-->\n";

  
  // write xml data header
  if (isBigEndian()) {
    outFile << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"BigEndian\">\n";
  } else {
    outFile << "<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n";
  }

  outFile << "<UnstructuredGrid>\n";
  
} // write_vtu_header

// =======================================================
// =======================================================
void write_vtk_metadata(std::ostream& outFile,
			int iStep,
			real_t time)
{

  outFile << "<FieldData>\n";

  outFile << "<DataArray type=\"Float32\" Name=\"CYCLE\" NumberOfTuples=\"1\" format=\"ascii\">"
	  << iStep
	  << "</DataArray>\n";

  outFile << "<DataArray type=\"Float32\" Name=\"TIME\" NumberOfTuples=\"1\" format=\"ascii\">"
      << time
      << "</DataArray>\n";

  outFile << "</FieldData>\n";
  
} // write_vtk_metadata


// =======================================================
// =======================================================
void write_vtu_footer(std::ostream& outFile)
{

  outFile << " </UnstructuredGrid>\n";
  outFile << "</VTKFile>\n";
  
} // write_vtu_footer


// =======================================================
// =======================================================
void save_VTK_SDM_3D(DataArray3d             Udata,
		     DataArray3d::HostMirror Uhost,
		     HydroParams& params,
		     ConfigMap& configMap,
		     int nbvar,
		     const std::map<int, std::string>& variables_names,
		     int iStep,
		     std::string debug_name)
{
  
  // const int nx = params.nx;
  // const int ny = params.ny;
  // const int nz = params.nz;

  // const int imin = params.imin;
  // const int imax = params.imax;

  // const int jmin = params.jmin;
  // const int jmax = params.jmax;

  // const int kmin = params.kmin;
  // const int kmax = params.kmax;

  // const int isize = params.isize;
  // const int jsize = params.jsize;
  // const int ksize = params.ksize;
  // const int ijsize = isize * jsize;
  // const int nbCells = isize * jsize * ksize;

  
  // const int ghostWidth = params.ghostWidth;
  
  // // copy device data to host
  // Kokkos::deep_copy(Uhost, Udata);
  
  // // local variables
  // int i, j, k, iVar;
  // std::string outputDir    = configMap.getString("output", "outputDir", "./");
  // std::string outputPrefix = configMap.getString("output", "outputPrefix", "output");
    
  // bool outputVtkAscii = configMap.getBool("output", "outputVtkAscii", false);

  // // check scalar data type
  // bool useDouble = false;

  // if (sizeof(real_t) == sizeof(double)) {
  //   useDouble = true;
  // }
  
  // // write iStep in string stepNum
  // std::ostringstream stepNum;
  // stepNum.width(7);
  // stepNum.fill('0');
  // stepNum << iStep;
  
  // // concatenate file prefix + file number + suffix
  // std::string filename;
  // if ( debug_name.empty() )
  //   filename = outputDir + "/" + outputPrefix + "_" + stepNum.str() + ".vti";
  // else
  //   filename = outputDir + "/" + outputPrefix + "_" + debug_name + "_" + stepNum.str() + ".vti";
  
  // // open file 
  // std::fstream outFile;
  // outFile.open(filename.c_str(), std::ios_base::out);
  
  // // write header

  // // if writing raw binary data (file does not respect XML standard)
  // if (outputVtkAscii)
  //   outFile << "<?xml version=\"1.0\"?>\n";
  
  // // write xml data header
  // if (isBigEndian()) {
  //   outFile << "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"BigEndian\">\n";
  // } else {
  //   outFile << "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"LittleEndian\">\n";
  // }

  // // write mesh extent
  // outFile << "  <ImageData WholeExtent=\""
  // 	  << 0 << " " << nx << " "
  // 	  << 0 << " " << ny << " "
  // 	  << 0 << " " << nz  << " "
  // 	  <<  "\" Origin=\"0 0 0\" Spacing=\"1 1 1\">\n";
  // outFile << "  <Piece Extent=\""
  // 	  << 0 << " " << nx << " "
  // 	  << 0 << " " << ny << " "
  // 	  << 0 << " " << nz << " "    
  // 	  << "\">\n";
  
  // outFile << "    <PointData>\n";
  // outFile << "    </PointData>\n";

  // if (outputVtkAscii) {
    
  //   outFile << "    <CellData>\n";
    
  //   // write data array (ascii), remove ghost cells
  //   for ( iVar=0; iVar<nbvar; iVar++) {
  //     outFile << "    <DataArray type=\"";
  //     if (useDouble)
  // 	outFile << "Float64";
  //     else
  // 	outFile << "Float32";
  //     outFile << "\" Name=\"" << variables_names.at(iVar) << "\" format=\"ascii\" >\n";
      
  //     for (int index=0; index<nbCells; ++index) {
  // 	//index2coord(index,i,j,k,isize,jsize,ksize);
	
  // 	// enforce the use of left layout (Ok for CUDA)
  // 	// but for OpenMP, we will need to transpose
  // 	k = index / ijsize;
  // 	j = (index - k*ijsize) / isize;
  // 	i = index - j*isize - k*ijsize;
	
  // 	if (k>=kmin+ghostWidth and k<=kmax-ghostWidth and
  // 	    j>=jmin+ghostWidth and j<=jmax-ghostWidth and
  // 	    i>=imin+ghostWidth and i<=imax-ghostWidth) {
  //   	outFile << Uhost(i,j,k,iVar) << " ";
  // 	}
  //     }
  //     outFile << "\n    </DataArray>\n";
  //   } // end for iVar

  //   outFile << "    </CellData>\n";

  //   // write footer
  //   outFile << "  </Piece>\n";
  //   outFile << "  </ImageData>\n";
  //   outFile << "</VTKFile>\n";

  // } else { // write data in binary format

  //   outFile << "    <CellData>" << std::endl;

  //   for (int iVar=0; iVar<nbvar; iVar++) {
  //     if (useDouble) {
  // 	outFile << "     <DataArray type=\"Float64\" Name=\"" ;
  //     } else {
  // 	outFile << "     <DataArray type=\"Float32\" Name=\"" ;
  //     }
  //     outFile << variables_names.at(iVar)
  // 	      << "\" format=\"appended\" offset=\""
  // 	      << iVar*nx*ny*nz*sizeof(real_t)+iVar*sizeof(unsigned int)
  // 	      <<"\" />" << std::endl;
  //   }

  //   outFile << "    </CellData>" << std::endl;
  //   outFile << "  </Piece>" << std::endl;
  //   outFile << "  </ImageData>" << std::endl;
    
  //   outFile << "  <AppendedData encoding=\"raw\">" << std::endl;

  //   // write the leading undescore
  //   outFile << "_";

  //   // then write heavy data (column major format)
  //   {
  //     unsigned int nbOfWords = nx*ny*nz*sizeof(real_t);
  //     for (int iVar=0; iVar<nbvar; iVar++) {
  // 	outFile.write((char *)&nbOfWords,sizeof(unsigned int));
  // 	 for (int k=kmin+ghostWidth; k<=kmax-ghostWidth; k++)
  // 	   for (int j=jmin+ghostWidth; j<=jmax-ghostWidth; j++)
  // 	     for (int i=imin+ghostWidth; i<=imax-ghostWidth; i++) {
  // 	       real_t tmp = Uhost(i, j, k, iVar);
  // 	       outFile.write((char *)&tmp,sizeof(real_t));
  // 	     }
  //     }
  //   }

  //   outFile << "  </AppendedData>" << std::endl;
  //   outFile << "</VTKFile>" << std::endl;

  // } // end ascii/binary heavy data write
  
  // outFile.close();

} // end save_VTK_SDM_3D

#ifdef USE_MPI
// =======================================================
// =======================================================
void save_VTK_2D_mpi(DataArray2d             Udata,
		     DataArray2d::HostMirror Uhost,
		     HydroParams& params,
		     ConfigMap& configMap,
		     int nbvar,
		     const std::map<int, std::string>& variables_names,
		     int iStep,
		     std::string debug_name)
{
  
  const int nx = params.nx;
  const int ny = params.ny;

  const int imin = params.imin;
  const int imax = params.imax;

  const int jmin = params.jmin;
  const int jmax = params.jmax;
  
  const int ghostWidth = params.ghostWidth;

  const real_t dx = params.dx;
  const real_t dy = params.dy;
  const real_t dz = dx;
  
  const int isize = params.isize;
  const int jsize = params.jsize;
  const int nbCells = isize*jsize;

//   int xmin=0, xmax=0, ymin=0, ymax=0;

//   xmin=params.myMpiPos[0]*nx   ;
//   xmax=params.myMpiPos[0]*nx+nx;
//   ymin=params.myMpiPos[1]*ny   ;
//   ymax=params.myMpiPos[1]*ny+ny;
  
//   // copy device data to host
//   Kokkos::deep_copy(Uhost, Udata);
  
//   // local variables
//   int i,j,iVar;
//   std::string outputDir    = configMap.getString("output", "outputDir", "./");
//   std::string outputPrefix = configMap.getString("output", "outputPrefix", "output");

//   bool outputVtkAscii = configMap.getBool("output", "outputVtkAscii", false);

//   // check scalar data type
//   bool useDouble = false;

//   if (sizeof(real_t) == sizeof(double)) {
//     useDouble = true;
//   }
  
//   // write iStep in string timeFormat
//   std::ostringstream timeFormat;
//   timeFormat.width(7);
//   timeFormat.fill('0');
//   timeFormat << iStep;

//   // write MPI rank in string rankFormat
//   std::ostringstream rankFormat;
//   rankFormat.width(5);
//   rankFormat.fill('0');
//   rankFormat << params.myRank;

//   // concatenate file prefix + file number + suffix
//   std::string filename;
//   if ( debug_name.empty() )
//     filename = outputDir+"/"+outputPrefix+"_time"+timeFormat.str()+"_mpi"+rankFormat.str()+".vti";
//   else
//     filename = outputDir+"/"+outputPrefix+"_"+debug_name +"_time"+timeFormat.str()+"_mpi"+rankFormat.str()+".vti";

//   // header file : parallel vti format
//   std::string headerFilename   = outputDir+"/"+outputPrefix+"_time"+timeFormat.str()+".pvti";

  
//   // open file 
//   std::fstream outFile;
//   outFile.open(filename.c_str(), std::ios_base::out);
  
//   // write header
//   if (params.myRank == 0) {
//     write_pvtu_header(headerFilename,
// 		      outputPrefix,
// 		      params,
// 		      nbvar,
// 		      variables_names,
// 		      iStep);
//   }
      
//   // if writing raw binary data (file does not respect XML standard)
//   if (outputVtkAscii)
//     outFile << "<?xml version=\"1.0\"?>\n";

//   // write xml data header
//   if (isBigEndian()) {
//     outFile << "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"BigEndian\">\n";
//   } else {
//     outFile << "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"LittleEndian\">\n";
//   }

//   // write mesh extent
//   outFile << "  <ImageData WholeExtent=\""
// 	  << xmin << " " << xmax << " " 
// 	  << ymin << " " << ymax << " " 
// 	  << 0    << " " << 0    << ""
// 	  << "\" Origin=\"0 0 0\" Spacing=\"" << dx << " " << dy << " " << dz << "\">" << std::endl;
//   outFile << "  <Piece Extent=\"" 
// 	  << xmin << " " << xmax << " " 
// 	  << ymin << " " << ymax << " " 
// 	  << 0    << " " << 1    << ""
// 	  << "\">" << std::endl;
  
//   outFile << "    <PointData>\n";
//   outFile << "    </PointData>\n";

//   if (outputVtkAscii) {

//     outFile << "    <CellData>\n";

//     // write data array (ascii), remove ghost cells
//     for ( iVar=0; iVar<nbvar; iVar++) {
//       outFile << "    <DataArray type=\"";
//       if (useDouble)
// 	outFile << "Float64";
//       else
// 	outFile << "Float32";
//       outFile << "\" Name=\"" << variables_names.at(iVar) << "\" format=\"ascii\" >\n";
      	
//       for (int index=0; index<nbCells; ++index) {
// 	//index2coord(index,i,j,isize,jsize);
	
// 	// enforce the use of left layout (Ok for CUDA)
// 	// but for OpenMP, we will need to transpose
// 	j = index / isize;
// 	i = index - j*isize;
	
// 	if (j>=jmin+ghostWidth and j<=jmax-ghostWidth and
// 	    i>=imin+ghostWidth and i<=imax-ghostWidth) {
// 	  outFile << Uhost(i, j, iVar) << " ";
// 	}
//       }
      
//       outFile << "\n    </DataArray>\n";
      
//     } // end for iVar
    
//     outFile << "    </CellData>\n";
    
//     // write footer
//     outFile << "  </Piece>\n";
//     outFile << "  </ImageData>\n";
//     outFile << "</VTKFile>\n";

//   } else { // write data in binary format

//     outFile << "    <CellData>" << std::endl;

//     for (int iVar=0; iVar<nbvar; iVar++) {
//       if (useDouble) {
// 	outFile << "     <DataArray type=\"Float64\" Name=\"" ;
//       } else {
// 	outFile << "     <DataArray type=\"Float32\" Name=\"" ;
//       }
//       outFile << variables_names.at(iVar)
// 	      << "\" format=\"appended\" offset=\""
// 	      << iVar*nx*ny*sizeof(real_t)+iVar*sizeof(unsigned int)
// 	      <<"\" />" << std::endl;
//     }

//     outFile << "    </CellData>" << std::endl;
//     outFile << "  </Piece>" << std::endl;
//     outFile << "  </ImageData>" << std::endl;
    
//     outFile << "  <AppendedData encoding=\"raw\">" << std::endl;

//     // write the leading undescore
//     outFile << "_";
//     // then write heavy data (column major format)
//     {
//       unsigned int nbOfWords = nx*ny*sizeof(real_t);
//       for (int iVar=0; iVar<nbvar; iVar++) {
// 	outFile.write((char *)&nbOfWords,sizeof(unsigned int));
// 	for (int j=jmin+ghostWidth; j<=jmax-ghostWidth; j++)
// 	  for (int i=imin+ghostWidth; i<=imax-ghostWidth; i++) {
// 	    real_t tmp = Uhost(i, j, iVar);
// 	    outFile.write((char *)&tmp,sizeof(real_t));
// 	  }
//       }
//     }

//     outFile << "  </AppendedData>" << std::endl;
//     outFile << "</VTKFile>" << std::endl;

//   } // end ascii/binary heavy data write
  
//   outFile.close();
  
// } // save_VTK_2D_mpi

// // =======================================================
// // =======================================================
// /**
//  * \param[in] Udata device data to save
//  * \param[in,out] Uhost host data temporary array before saving to file
//  */
// void save_VTK_3D_mpi(DataArray3d             Udata,
// 		     DataArray3d::HostMirror Uhost,
// 		     HydroParams& params,
// 		     ConfigMap& configMap,
// 		     int nbvar,
// 		     const std::map<int, std::string>& variables_names,
// 		     int iStep,
// 		     std::string debug_name)
// {
  
//   const int nx = params.nx;
//   const int ny = params.ny;
//   const int nz = params.nz;

//   const int imin = params.imin;
//   const int imax = params.imax;

//   const int jmin = params.jmin;
//   const int jmax = params.jmax;

//   const int kmin = params.kmin;
//   const int kmax = params.kmax;

//   const int ghostWidth = params.ghostWidth;

//   const real_t dx = params.dx;
//   const real_t dy = params.dy;
//   const real_t dz = params.dz;

//   const int isize = params.isize;
//   const int jsize = params.jsize;
//   const int ksize = params.ksize;
//   const int ijsize = isize*jsize;
//   const int nbCells = isize*jsize*ksize;

//   int xmin=0, xmax=0, ymin=0, ymax=0, zmin=0, zmax=0;
//   xmin=params.myMpiPos[0]*nx   ;
//   xmax=params.myMpiPos[0]*nx+nx;
//   ymin=params.myMpiPos[1]*ny   ;
//   ymax=params.myMpiPos[1]*ny+ny;
//   zmin=params.myMpiPos[2]*nz   ;
//   zmax=params.myMpiPos[2]*nz+nz;

//   // copy device data to host
//   Kokkos::deep_copy(Uhost, Udata);
  
//   // local variables
//   int i,j,k,iVar;
//   std::string outputDir    = configMap.getString("output", "outputDir", "./");
//   std::string outputPrefix = configMap.getString("output", "outputPrefix", "output");

//   bool outputVtkAscii = configMap.getBool("output", "outputVtkAscii", false);

//   // check scalar data type
//   bool useDouble = false;

//   if (sizeof(real_t) == sizeof(double)) {
//     useDouble = true;
//   }
  
//   // write iStep in string timeFormat
//   std::ostringstream timeFormat;
//   timeFormat.width(7);
//   timeFormat.fill('0');
//   timeFormat << iStep;

//   // write MPI rank in string rankFormat
//   std::ostringstream rankFormat;
//   rankFormat.width(5);
//   rankFormat.fill('0');
//   rankFormat << params.myRank;

//   // concatenate file prefix + file number + suffix
//   std::string filename;
//   if ( debug_name.empty() )
//     filename = outputDir+"/"+outputPrefix+"_time"+timeFormat.str()+"_mpi"+rankFormat.str()+".vti";
//   else
//     filename = outputDir+"/"+outputPrefix+"_"+debug_name +"_time"+timeFormat.str()+"_mpi"+rankFormat.str()+".vti";

//   // header file : parallel vti format
//   std::string headerFilename   = outputDir+"/"+outputPrefix+"_time"+timeFormat.str()+".pvti";

  
//   // open file 
//   std::fstream outFile;
//   outFile.open(filename.c_str(), std::ios_base::out);
  
//   // write header
//   if (params.myRank == 0) {
//     write_pvti_header(headerFilename,
// 		      outputPrefix,
// 		      params,
// 		      nbvar,
// 		      variables_names,
// 		      iStep);
//   }
      
//   // if writing raw binary data (file does not respect XML standard)
//   if (outputVtkAscii)
//     outFile << "<?xml version=\"1.0\"?>\n";

//   // write xml data header
//   if (isBigEndian()) {
//     outFile << "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"BigEndian\">\n";
//   } else {
//     outFile << "<VTKFile type=\"ImageData\" version=\"0.1\" byte_order=\"LittleEndian\">\n";
//   }

//   // write mesh extent
//   outFile << "  <ImageData WholeExtent=\""
// 	  << xmin << " " << xmax << " " 
// 	  << ymin << " " << ymax << " " 
// 	  << zmin << " " << zmax << ""
// 	  << "\" Origin=\"0 0 0\" Spacing=\"" << dx << " " << dy << " " << dz << "\">" << std::endl;
//   outFile << "  <Piece Extent=\"" 
// 	  << xmin << " " << xmax << " " 
// 	  << ymin << " " << ymax << " " 
// 	  << zmin << " " << zmax << ""
// 	  << "\">" << std::endl;
  
//   outFile << "    <PointData>\n";
//   outFile << "    </PointData>\n";

//   if (outputVtkAscii) {

//     outFile << "    <CellData>\n";

//     // write data array (ascii), remove ghost cells
//     for ( iVar=0; iVar<nbvar; iVar++) {
//       outFile << "    <DataArray type=\"";
//       if (useDouble)
// 	outFile << "Float64";
//       else
// 	outFile << "Float32";
//       outFile << "\" Name=\"" << variables_names.at(iVar) << "\" format=\"ascii\" >\n";
      
//       for (int index=0; index<nbCells; ++index) {
// 	//index2coord(index,i,j,k,isize,jsize,ksize);
	
// 	// enforce the use of left layout (Ok for CUDA)
// 	// but for OpenMP, we will need to transpose
// 	k = index / ijsize;
// 	j = (index - k*ijsize) / isize;
// 	i = index - j*isize - k*ijsize;
	
// 	if (k>=kmin+ghostWidth and k<=kmax-ghostWidth and
// 	    j>=jmin+ghostWidth and j<=jmax-ghostWidth and
// 	    i>=imin+ghostWidth and i<=imax-ghostWidth) {
// 	  outFile << Uhost(i,j,k,iVar) << " ";
// 	}
//       }
      
//       outFile << "\n    </DataArray>\n";

//     } // end for iVar
    
//     outFile << "    </CellData>\n";
    
//     // write footer
//     outFile << "  </Piece>\n";
//     outFile << "  </ImageData>\n";
//     outFile << "</VTKFile>\n";

//   } else { // write data in binary format

//     outFile << "    <CellData>" << std::endl;

//     for (int iVar=0; iVar<nbvar; iVar++) {
//       if (useDouble) {
// 	outFile << "     <DataArray type=\"Float64\" Name=\"" ;
//       } else {
// 	outFile << "     <DataArray type=\"Float32\" Name=\"" ;
//       }
//       outFile << variables_names.at(iVar)
// 	      << "\" format=\"appended\" offset=\""
// 	      << iVar*nx*ny*nz*sizeof(real_t)+iVar*sizeof(unsigned int)
// 	      <<"\" />" << std::endl;
//     }

//     outFile << "    </CellData>" << std::endl;
//     outFile << "  </Piece>" << std::endl;
//     outFile << "  </ImageData>" << std::endl;
    
//     outFile << "  <AppendedData encoding=\"raw\">" << std::endl;

//     // write the leading undescore
//     outFile << "_";
//     // then write heavy data (column major format)
//     {
//       unsigned int nbOfWords = nx*ny*nz*sizeof(real_t);
//       for (int iVar=0; iVar<nbvar; iVar++) {
// 	outFile.write((char *)&nbOfWords,sizeof(unsigned int));
// 	for (int k=kmin+ghostWidth; k<=kmax-ghostWidth; k++) {
// 	  for (int j=jmin+ghostWidth; j<=jmax-ghostWidth; j++) {
// 	    for (int i=imin+ghostWidth; i<=imax-ghostWidth; i++) {
// 	      real_t tmp = Uhost(i, j, k, iVar);
// 	      outFile.write((char *)&tmp,sizeof(real_t));
// 	    } // for i
// 	  } // for j
// 	} // for k
//       } // for iVar
//     }
    
//     outFile << "  </AppendedData>" << std::endl;
//     outFile << "</VTKFile>" << std::endl;
    
//   } // end ascii/binary heavy data write
  
//   outFile.close();
  
// } // save_VTK_3D_mpi

/*
 * write pvti header in a separate file.
 */
// =======================================================
// =======================================================
void write_pvtu_header(std::string headerFilename,
		       std::string outputPrefix,
		       HydroParams& params,
		       int nbvar,
		       const std::map<int, std::string>& varNames,
		       int iStep)
{
  // file handler
  std::fstream outHeader;
  
  // dummy string here, when using the full VTK API, data can be compressed
  // here, no compression used
  std::string compressor("");
  
  // check scalar data type
  bool useDouble = false;
  
  if (sizeof(real_t) == sizeof(double)) {
    useDouble = true;
  }
  
  const int dimType = params.dimType;
  const int nProcs = params.nProcs;
  
  // write iStep in string timeFormat
  std::ostringstream timeFormat;
  timeFormat.width(7);
  timeFormat.fill('0');
  timeFormat << iStep;
  
  // local sub-domain sizes
  const int nx = params.nx;
  const int ny = params.ny;
  const int nz = params.nz;

  // sizes of MPI Cartesian topology
  const int mx = params.mx;
  const int my = params.my;
  const int mz = params.mz;

  const real_t dx = params.dx;
  const real_t dy = params.dy;
  const real_t dz = (dimType == THREE_D) ? params.dz : params.dx;

  // open pvtu header file
  outHeader.open (headerFilename.c_str(), std::ios_base::out);
  
  outHeader << "<?xml version=\"1.0\"?>" << std::endl;

  // print data and time
  outHeader << "<!-- \n";
  outHeader << "# vtk DataFile Version 3.0"
	    << '\n'
	    << "#This file was generated by ppkMHD";
  if (outputDataAndTime) {
    outHeader << " on " << get_current_date();
  } else {
    outHeader << ".";
  }
  outHeader << "\n-->\n";
  
  
  if (isBigEndian())
    outHeader << "<VTKFile type=\"PUnstructuredGrid\" version=\"0.1\" byte_order=\"BigEndian\"" << compressor << ">" << std::endl;
  else
    outHeader << "<VTKFile type=\"PUnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\"" << compressor << ">" << std::endl;

  outHeader << "  <PUnstructuredGrid GhostLevel=\"0\">\n";
  
  outHeader << "    <PCells>\n";
  outHeader << "      <PDataArray type=\"Int32\" Name=\"connectivity\" NumberOfComponents=\"1\"/>\n"; 
  outHeader << "      <PDataArray type=\"Int32\" Name=\"offsets\"      NumberOfComponents=\"1\"/>\n";
  outHeader << "      <PDataArray type=\"UInt8\" Name=\"types\"        NumberOfComponents=\"1\"/>\n"; 
  outHeader << "    </PCells>\n";

     
  outHeader << "    <PCellData Scalars=\"Scalars_\">" << std::endl;
  for (int iVar=0; iVar<nbvar; iVar++) {
    if (useDouble) 
      outHeader << "      <PDataArray type=\"Float64\" Name=\""<< varNames.at(iVar)<<"\"/>" << std::endl;
    else
      outHeader << "      <PDataArray type=\"Float32\" Name=\""<< varNames.at(iVar)<<"\"/>" << std::endl;	  
  }
  outHeader << "    </PCellData>" << std::endl;
  
  // one piece per MPI process
  for (int iPiece=0; iPiece<nProcs; ++iPiece) {
    std::ostringstream pieceFormat;
    pieceFormat.width(5);
    pieceFormat.fill('0');
    pieceFormat << iPiece;
    std::string pieceFilename   = outputPrefix+"_time"+timeFormat.str()+"_mpi"+pieceFormat.str()+".vtu";
    outHeader << "    <Piece Source=\"" << pieceFilename << "\"/>" << std::endl;
  } 
  outHeader << "</PUnstructuredGrid>" << std::endl;
  outHeader << "</VTKFile>" << std::endl;
  
  // close header file
  outHeader.close();
  
  // end writing pvtu header
  
} // write_pvtu_header

#endif // USE_MPI

} // namespace io

} // namespace ppkMHD
